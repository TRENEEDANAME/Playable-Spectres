class X2Ability_PASpectre extends X2Ability config(GameData_PASpectre_Ability);

var localized string WillLostFriendlyName, WillLossString;
var localized string ShadowbindUnconsciousFriendlyName;

var name PA_Spectre_ShadownBoundLinkName;

var config bool PASpectre_DoesHorror_ExcludeFriendlyToSource;
var config bool PASpectre_DoesHorror_ExcludeRobotic;
var config bool PASpectre_DoesHorror_FailOnNonUnits;
var config bool PASpectre_DoesHorror_ExcludeAlien;
var config bool PASpectre_DoesHorror_IgnoreArmor;
var config bool PASpectre_DoesHorror_ConsumeAllPoints;

var config int PASpectre_Horror_ActionPointCost;
var config int PASpectre_Horror_Cooldown;
var config int PASpectre_Horror_ToHitBaseChance;
var config int PA_Spectre_ShadownBound_ActionPoints;
var config int PA_Spectre_ShadownBound_Cooldown;

var name SireZombieLinkName;


static function array<X2DataTemplate> CreateTemplates()
{
	local array<X2DataTemplate> Templates;

	Templates.AddItem(CreatePA_Horror());
	Templates.AddItem(AddLinkedEffectAbility(default.SireZombieLinkName, default.SireZombieLinkName, SireZombieLink_BuildVisualizationSyncDelegate));
	Templates.AddItem(AddKillShadow());

	Templates.AddItem(CreateShadowInitializationAbility());

	return Templates;
}

static function X2AbilityTemplate CreatePA_Horror()
{
	local X2AbilityTemplate Template;
	local X2AbilityCost_ActionPoints ActionPointCost;
	local X2AbilityCooldown Cooldown;
	local X2AbilityToHitCalc_RollStat RollStat;
	local X2Condition_UnitProperty UnitPropertyCondition;
	local X2Condition_UnitImmunities UnitImmunityCondition;
	local X2Effect_ApplyWeaponDamage HorrorDamageEffect;
	local X2Effect_PerkAttachForFX WillLossEffect;
	local X2Effect_PA_LifeSteal PA_LifeStealEffect;
	local array<name> SkipExclusions;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'PA_Horror');

	Template.AbilitySourceName = 'eAbilitySource_Psionic';
	Template.IconImage = "img:///UILibrary_XPACK_Common.PerkIcons.UIPerk_horror";
	Template.Hostility = eHostility_Offensive;

	ActionPointCost = new class'X2AbilityCost_ActionPoints';
	ActionPointCost.iNumPoints = default.PASpectre_Horror_ActionPointCost;
	ActionPointCost.bConsumeAllPoints = default.PASpectre_DoesHorror_ConsumeAllPoints;
	Template.AbilityCosts.AddItem(ActionPointCost);

	Cooldown = new class'X2AbilityCooldown';
	Cooldown.iNumTurns = default.PASpectre_Horror_Cooldown;
	Template.AbilityCooldown = Cooldown;

	Template.AbilityTargetStyle = default.SimpleSingleTarget;
	Template.AbilityTriggers.AddItem(default.PlayerInputTrigger);

	// This will be a stat contest
	RollStat = new class'X2AbilityToHitCalc_RollStat';
	RollStat.StatToRoll = eStat_Will;
	RollStat.BaseChance = default.PASpectre_Horror_ToHitBaseChance;
	Template.AbilityToHitCalc = RollStat;

	// Shooter conditions
	Template.AbilityShooterConditions.AddItem(default.LivingShooterProperty);
	SkipExclusions.AddItem(class'X2StatusEffects'.default.BurningName);
	Template.AddShooterEffectExclusions(SkipExclusions);

	// Target conditions
	UnitPropertyCondition = new class'X2Condition_UnitProperty';
	UnitPropertyCondition.ExcludeDead = true;
	UnitPropertyCondition.ExcludeFriendlyToSource = default.PASpectre_DoesHorror_ExcludeFriendlyToSource;
	UnitPropertyCondition.ExcludeRobotic = default.PASpectre_DoesHorror_ExcludeRobotic;
	UnitPropertyCondition.FailOnNonUnits = default.PASpectre_DoesHorror_FailOnNonUnits;
	UnitPropertyCondition.ExcludeAlien = default.PASpectre_DoesHorror_ExcludeAlien;
	Template.AbilityTargetConditions.AddItem(UnitPropertyCondition);

	Template.AbilityTargetConditions.AddItem(default.GameplayVisibilityCondition);

	UnitImmunityCondition = new class'X2Condition_UnitImmunities';
	UnitImmunityCondition.AddExcludeDamageType('Mental');
	UnitImmunityCondition.bOnlyOnCharacterTemplate = true;
	Template.AbilityTargetConditions.AddItem(UnitImmunityCondition);

	// Target Effects
	WillLossEffect = new class'X2Effect_PerkAttachForFX';
	WillLossEffect.BuildPersistentEffect(1, false, false);
	WillLossEffect.DuplicateResponse = eDupe_Allow;
	WillLossEffect.EffectName = 'HorrorWillLossEffect';
	Template.AddTargetEffect(WillLossEffect);

	HorrorDamageEffect = new class'X2Effect_ApplyWeaponDamage';
	HorrorDamageEffect.bIgnoreBaseDamage = true;
	HorrorDamageEffect.DamageTag = 'Horror';
	HorrorDamageEffect.bIgnoreArmor = default.PASpectre_DoesHorror_IgnoreArmor;
	Template.AddTargetEffect(HorrorDamageEffect);

	PA_LifeStealEffect = new class'X2Effect_PA_LifeSteal';
	Template.AddTargetEffect(PA_LifeStealEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildInterruptGameStateFn = TypicalAbility_BuildInterruptGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;

	Template.bShowActivation = true;

	Template.CinescriptCameraType = "Spectre_Horror";

	Template.LostSpawnIncreasePerUse = class'X2AbilityTemplateManager'.default.StandardShotLostSpawnIncreasePerUse;

	Template.PostActivationEvents.AddItem('PA_HorrorActivated');
//BEGIN AUTOGENERATED CODE: Template Overrides 'Horror'
	Template.bFrameEvenWhenUnitIsHidden = true;
	Template.ActionFireClass = class'XComGame.X2Action_Fire_Horror';
	Template.CustomFireAnim = 'HL_Horror_StartA';
//END AUTOGENERATED CODE: Template Overrides 'Horror'

	return Template;
}

static function X2AbilityTemplate AddKillShadow()
{
	return AddKillLinkedUnits('KillSiredZombies', default.SireZombieLinkName, class'X2Action_ZombieSireDeath', true);
}

static function X2AbilityTemplate AddKillLinkedUnits( Name AbilityName, Name LinkEffectName, class<X2Action> DeathClass, bool ApplyOnImpair=false )
{
	local X2AbilityTemplate Template;
	local X2AbilityTrigger_EventListener DeathEventListener;
	local X2AbilityTrigger_EventListener ImpairedEventListener;
	local X2AbilityTrigger_EventListener EventTrigger;
	local X2Condition_UnitEffectsWithAbilitySource TargetEffectCondition;
	local X2Effect_KillUnit KillUnitEffect;

	`CREATE_X2ABILITY_TEMPLATE(Template, AbilityName);
	Template.IconImage = "img:///UILibrary_PerkIcons.UIPerk_hunter";

	Template.bDontDisplayInAbilitySummary = true;
	Template.AbilitySourceName = 'eAbilitySource_Standard';
	Template.eAbilityIconBehaviorHUD = EAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	
	// This ability fires when the sectoid dies
	DeathEventListener = new class'X2AbilityTrigger_EventListener';
	DeathEventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
	DeathEventListener.ListenerData.EventID = 'UnitDied';
	DeathEventListener.ListenerData.Filter = eFilter_Unit;
	DeathEventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_SelfWithAdditionalTargets;
	Template.AbilityTriggers.AddItem(DeathEventListener);

	//	Trigger if the source is removed from play (e.g. evacs)
	EventTrigger = new class'X2AbilityTrigger_EventListener';
	EventTrigger.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventTrigger.ListenerData.EventID = 'UnitRemovedFromPlay';
	EventTrigger.ListenerData.Filter = eFilter_Unit;
	EventTrigger.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_SelfIgnoreCache;
	EventTrigger.ListenerData.Priority = 75;	// We need this to happen before the unit is actually removed from play
	Template.AbilityTriggers.AddItem(EventTrigger);

	if (ApplyOnImpair)
	{
		// Also activate when the sectoid becomes impaired (mainly to prevent them getting mind-controlled and having to propagate that along...)
		ImpairedEventListener = new class'X2AbilityTrigger_EventListener';
		ImpairedEventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
		ImpairedEventListener.ListenerData.EventID = 'ImpairingEffect';
		ImpairedEventListener.ListenerData.Filter = eFilter_Unit;
		ImpairedEventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_SelfWithAdditionalTargets;
		Template.AbilityTriggers.AddItem(ImpairedEventListener);
	}

	Template.AbilityMultiTargetStyle = new class'X2AbilityMultiTarget_AllUnits';

	TargetEffectCondition = new class'X2Condition_UnitEffectsWithAbilitySource';
	TargetEffectCondition.AddRequireEffect(LinkEffectName, 'AA_UnitIsImmune');
	Template.AbilityMultiTargetConditions.AddItem(TargetEffectCondition);

	KillUnitEffect = new class'X2Effect_KillUnit';
	KillUnitEffect.BuildPersistentEffect(1, false, false, false, eGameRule_PlayerTurnBegin);
	KillUnitEffect.DeathActionClass = DeathClass;
	KillUnitEffect.VisualizationFn = BuildVisualization_SireDeathEffect;
	Template.AddMultiTargetEffect(KillUnitEffect);

	Template.bSkipFireAction = true;
	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.CinescriptCameraType = "Zombie_SireDeath";

	return Template;
}

simulated function BuildVisualization_SireDeathEffect(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata, name EffectApplyResult)
{
	local XComGameState_Unit UnitState;
	local X2Action_CameraLookAt LookAtAction;

	UnitState = XComGameState_Unit(ActionMetadata.StateObject_NewState);
	if (UnitState != None)
	{
		LookAtAction = X2Action_CameraLookAt(class'X2Action_CameraLookAt'.static.AddToVisualizationTree(ActionMetadata, VisualizeGameState.GetContext(), false, ActionMetadata.LastActionAdded));
		LookAtAction.LookAtDuration = 2.0f;
		LookAtAction.UseTether = false;
		LookAtAction.LookAtObject = UnitState;
		LookAtAction.BlockUntilActorOnScreen = true;
	}
}

static function X2AbilityTemplate AddLinkedEffectAbility(Name AbilityName, Name LinkedEffectName, delegate<BuildVisualizationSyncDelegate> VisSyncFn)
{
	local X2AbilityTemplate Template;
	local X2AbilityTrigger_Placeholder PlaceholderTrigger;
	local X2Effect_Persistent SireZombieLinkEffect;

	`CREATE_X2ABILITY_TEMPLATE(Template, AbilityName);
	Template.IconImage = "img:///UILibrary_PerkIcons.UIPerk_sectoid_psireanimate";

	Template.AbilityTargetStyle = new class'X2AbilityTarget_Single';

	PlaceholderTrigger = new class'X2AbilityTrigger_Placeholder';
	Template.AbilityTriggers.AddItem(PlaceholderTrigger);

	Template.Hostility = eHostility_Neutral;
	Template.eAbilityIconBehaviorHUD = eAbilityIconBehavior_NeverShow;
	Template.AbilitySourceName = 'eAbilitySource_Psionic';

	// Create an effect that will be attached to the spawned zombie
	SireZombieLinkEffect = new class'X2Effect_Persistent';
	SireZombieLinkEffect.BuildPersistentEffect(1, true, false, true);
	SireZombieLinkEffect.EffectName = LinkedEffectName;
	Template.AddTargetEffect(SireZombieLinkEffect);

	Template.BuildNewGameStateFn = Empty_BuildGameState;
	Template.BuildVisualizationFn = none;

	//We re-run the X2Action_CreateDoppelganger on load, to restore the appearance and tether of the zombie.
	Template.BuildAffectedVisualizationSyncFn = VisSyncFn;

	return Template;
}

simulated function SireZombieLink_BuildVisualizationSyncDelegate(name EffectName, XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata)
{
	local XComGameStateContext_Ability AbilityContext;

	local XComGameState_Unit ZombieUnitState;
	local XComGameState_Unit DeadUnitState;

	local XComGameState_Ability ZombieAbility;

	local X2Action_CreateDoppelganger DoppelgangerAction;

	//Only run on the SireZombieLink effect
	if (EffectName != default.SireZombieLinkName)
		return;
	
	//Find the context and unit states associated with the Psi Reanimation ability used
	AbilityContext = XComGameStateContext_Ability(VisualizeGameState.GetContext());
	if (AbilityContext == None)
		return;

	ZombieUnitState = XComGameState_Unit(ActionMetadata.StateObject_NewState);
	DeadUnitState = XComGameState_Unit(VisualizeGameState.GetGameStateForObjectID(AbilityContext.InputContext.PrimaryTarget.ObjectID));
	if (ZombieUnitState == None || DeadUnitState == None)
		return;

	ZombieAbility = XComGameState_Ability(VisualizeGameState.GetGameStateForObjectID(AbilityContext.InputContext.AbilityRef.ObjectID));
	if (ZombieAbility == none)
		return;

	//Perform X2Action_CreateDoppelganger on the zombie, as we did when it was spawned, to grab the original unit's appearance and tether effect.
	DoppelgangerAction = X2Action_CreateDoppelganger(class'X2Action_CreateDoppelganger'.static.AddToVisualizationTree(ActionMetadata, AbilityContext));
	DoppelgangerAction.OriginalUnitState = DeadUnitState;
	DoppelgangerAction.ShouldCopyAppearance = 
		ZombieUnitState.GetMyTemplateName() == 'Shadowbind' ||
	DoppelgangerAction.ReanimatorAbilityState = ZombieAbility;
	DoppelgangerAction.bIgnorePose = true;
}

simulated function XComGameState Empty_BuildGameState( XComGameStateContext Context )
{
	//	This is an explicit placeholder so that ValidateTemplates doesn't think something is wrong with the ability template.
	`RedScreen("This function should never be called.");
	return none;
}

static function X2AbilityTemplate AddKillShadow()
{
	return AddKillLinkedUnits('KillSiredZombies', default.SireZombieLinkName, class'X2Action_ZombieSireDeath', true);
}

static function X2AbilityTemplate AddKillLinkedUnits( Name AbilityName, Name LinkEffectName, class<X2Action> DeathClass, bool ApplyOnImpair=false )
{
	local X2AbilityTemplate Template;
	local X2AbilityTrigger_EventListener DeathEventListener;
	local X2AbilityTrigger_EventListener ImpairedEventListener;
	local X2AbilityTrigger_EventListener EventTrigger;
	local X2Condition_UnitEffectsWithAbilitySource TargetEffectCondition;
	local X2Effect_KillUnit KillUnitEffect;

	`CREATE_X2ABILITY_TEMPLATE(Template, AbilityName);
	Template.IconImage = "img:///UILibrary_PerkIcons.UIPerk_hunter";

	Template.bDontDisplayInAbilitySummary = true;
	Template.AbilitySourceName = 'eAbilitySource_Standard';
	Template.eAbilityIconBehaviorHUD = EAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;

	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;
	
	// This ability fires when the sectoid dies
	DeathEventListener = new class'X2AbilityTrigger_EventListener';
	DeathEventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
	DeathEventListener.ListenerData.EventID = 'UnitDied';
	DeathEventListener.ListenerData.Filter = eFilter_Unit;
	DeathEventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_SelfWithAdditionalTargets;
	Template.AbilityTriggers.AddItem(DeathEventListener);

	//	Trigger if the source is removed from play (e.g. evacs)
	EventTrigger = new class'X2AbilityTrigger_EventListener';
	EventTrigger.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventTrigger.ListenerData.EventID = 'UnitRemovedFromPlay';
	EventTrigger.ListenerData.Filter = eFilter_Unit;
	EventTrigger.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_SelfIgnoreCache;
	EventTrigger.ListenerData.Priority = 75;	// We need this to happen before the unit is actually removed from play
	Template.AbilityTriggers.AddItem(EventTrigger);

	if (ApplyOnImpair)
	{
		// Also activate when the sectoid becomes impaired (mainly to prevent them getting mind-controlled and having to propagate that along...)
		ImpairedEventListener = new class'X2AbilityTrigger_EventListener';
		ImpairedEventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
		ImpairedEventListener.ListenerData.EventID = 'ImpairingEffect';
		ImpairedEventListener.ListenerData.Filter = eFilter_Unit;
		ImpairedEventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_SelfWithAdditionalTargets;
		Template.AbilityTriggers.AddItem(ImpairedEventListener);
	}

	Template.AbilityMultiTargetStyle = new class'X2AbilityMultiTarget_AllUnits';

	TargetEffectCondition = new class'X2Condition_UnitEffectsWithAbilitySource';
	TargetEffectCondition.AddRequireEffect(LinkEffectName, 'AA_UnitIsImmune');
	Template.AbilityMultiTargetConditions.AddItem(TargetEffectCondition);

	KillUnitEffect = new class'X2Effect_KillUnit';
	KillUnitEffect.BuildPersistentEffect(1, false, false, false, eGameRule_PlayerTurnBegin);
	KillUnitEffect.DeathActionClass = DeathClass;
	KillUnitEffect.VisualizationFn = BuildVisualization_SireDeathEffect;
	Template.AddMultiTargetEffect(KillUnitEffect);

	Template.bSkipFireAction = true;
	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = TypicalAbility_BuildVisualization;
	Template.CinescriptCameraType = "Zombie_SireDeath";

	return Template;
}

simulated function BuildVisualization_SireDeathEffect(XComGameState VisualizeGameState, out VisualizationActionMetadata ActionMetadata, name EffectApplyResult)
{
	local XComGameState_Unit UnitState;
	local X2Action_CameraLookAt LookAtAction;

	UnitState = XComGameState_Unit(ActionMetadata.StateObject_NewState);
	if (UnitState != None)
	{
		LookAtAction = X2Action_CameraLookAt(class'X2Action_CameraLookAt'.static.AddToVisualizationTree(ActionMetadata, VisualizeGameState.GetContext(), false, ActionMetadata.LastActionAdded));
		LookAtAction.LookAtDuration = 2.0f;
		LookAtAction.UseTether = false;
		LookAtAction.LookAtObject = UnitState;
		LookAtAction.BlockUntilActorOnScreen = true;
	}
}

static function X2AbilityTemplate CreateShadowInitializationAbility()
{
	local X2AbilityTemplate Template;
	local X2Effect_DamageImmunity DamageImmunity;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'ZombieInitialization');
	Template.IconImage = "img:///UILibrary_PerkIcons.UIPerk_mentalfortress"; 

	Template.AbilitySourceName = 'eAbilitySource_Perk';
	Template.eAbilityIconBehaviorHUD = EAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Neutral;
	
	Template.AbilityToHitCalc = default.DeadEye;
	Template.AbilityTargetStyle = default.SelfTarget;

	Template.AbilityTriggers.AddItem(default.UnitPostBeginPlayTrigger);

	// Build the immunities
	DamageImmunity = new class'X2Effect_DamageImmunity';
	DamageImmunity.BuildPersistentEffect(1, true, true, true);
	DamageImmunity.ImmuneTypes.AddItem(class'X2Item_DefaultDamageTypes'.default.DisorientDamageType);
	DamageImmunity.ImmuneTypes.AddItem('stun');
	DamageImmunity.ImmuneTypes.AddItem('Unconscious');
	Template.AddTargetEffect(DamageImmunity);


	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;

	return Template;
}